#!/usr/bin/env python
# -*- coding: utf-8 -*-
#from __future__ import division

import numpy as np


#pythran export rate_limiter(float[], float[], int, int)
def rate_limiter(new_throttle, last_throttle, rising_limit, falling_limit):
    """Models the change in thruster's throttle.

    http://www.mathworks.co.uk/help/simulink/slref/ratelimiter.html

    :param last_throttle: result of a previous iteration
    :param new_throttle:
    :param rising_limit: rising rate limit between two samples
    :param falling_limit: falling rate limit between two samples
    :return: next_throttle: the new throttle after applying rate limits
    """
    diff_throttle = new_throttle - last_throttle
    next_throttle = np.zeros_like(new_throttle)

    for i, dth in enumerate(diff_throttle):
        if dth > rising_limit:
            next_throttle[i] = last_throttle[i] + rising_limit
        elif dth < -falling_limit:
            next_throttle[i] = last_throttle[i] - falling_limit
        else:
            next_throttle[i] = new_throttle[i]

    return next_throttle


#pythran export estimate_current(float[], float[][])
def estimate_current(throttle, coeff):
    """This function is calculating the current used by the thrusters from thruster commands

    It returns the predicted currents for each thruster using an exponential fitting.

    :param throttle: np.array of shape (N,)
    :param coeff: matrix (N,8) of model coefficients
    :return: estimated_current: np.array of shape (6,)
    """

    # init and check signs
    estimated_current = np.zeros_like(throttle)

    for i, th in enumerate(throttle):
        if th > 1:
            estimated_current[i] = coeff[i, 0] * np.exp(coeff[i, 1] * th) + coeff[i, 2] * np.exp(coeff[i, 3] * th)
        elif th < -1:
            estimated_current[i] = coeff[i, 4] * np.exp(coeff[i, 5] * th) + coeff[i, 6] * np.exp(coeff[i, 7] * th)
        else:
            estimated_current[i] = 0

    # take into account the effect of small speeds and approximation error (preventing negative values)
    return np.maximum(estimated_current, 0.0)


#pythran export estimate_forces(float[], float[], float[])
def estimate_forces(throttle, current, coeff):
    """This function calculates the thrust generated by thrusters from speeds and currents.

    The output is in kilograms as described in thruster's data sheet.

    :param throttle: thrusters input commands (throttle requested, percentage)
    :param current: thruster output currents (measured or predicted by the model, amps)
    :param coeff: equation coefficients: ax^3 + bx^2 + cx (if x >= 0) and dx^3 + ex^2 + fx (if x < 0)
    :return: estimated thrust generate by thrusters (in Newtons)
    """

    estimated_thrust = np.zeros(len(current))

    for i in xrange(len(current)):
        if throttle[i] >= 0:
            estimated_thrust[i] = coeff[0] * (current[i]**3) + coeff[1] * (current[i]**2) + coeff[2] * current[i]
        else:
            estimated_thrust[i] = -(coeff[3] * (current[i]**3) + coeff[4] * (current[i]**2) + coeff[5] * current[i])

    return estimated_thrust * 9.81


#pythran export estimate_throttle(float[], float[][], float[], float, float)
def estimate_throttle(force_request, coeff, linear, threshold, max_force):
    """This function calculates the throttle that needs to be sent to the thrusters to apply input
    forces. Inverse of T(i(v)) -> v(T) has been fitted using the thrusters data sheet, thus internally it use kilograms.
    
    :param force_request:   requested forces from the controller (N x 1) [Newtons]
    :param threshold:       symmetric limit for the linear approximation (1 x 1) [Newtons]
    :param coeff:           coefficient matrix for inverse non-linear model (N x 8)
    :param linear:          coefficient array for inverse linearized model (N x 1)
    :param max_force:       maximum model force (this is used to prevent wrong estimations)

    :return: throttle_required:     array of required throttle values to produce the requested force (N x 1)
    """

    # calculate required thrust and limit according to vehicle specs
    #   thrust_request: is in kilograms as the fitting is done using thruster's data sheet
    throttle_required = np.zeros_like(force_request)
    thrust_request = np.clip(force_request, -max_force, max_force) / 9.81

    for i, thrust in enumerate(thrust_request):
        if thrust > threshold:
            throttle_required[i] = coeff[i, 0] * np.exp(coeff[i, 1] * thrust) + coeff[i, 2] * np.exp(coeff[i, 3] * thrust)
        elif thrust < -threshold:
            throttle_required[i] = coeff[i, 4] * np.exp(coeff[i, 5] * -thrust) + coeff[i, 6] * np.exp(coeff[i, 7] * -thrust)
        else:
            throttle_required[i] = (linear[i] / threshold) * thrust

    return np.clip(throttle_required, -100, 100)


# def thruster_model_forward(throttle, th_model=(0,1,2,3,4,5)):
#     """This functions applies the forward thruster model returning the estimated forces generated by the thrusters.
#
#     :param throttle: thrusters input commands (throttle requested, percentage)
#     :return: numpy.ndarray of estimated forces generated by the thrusters according to their models
#     """
#
#     est_current = estimate_current(throttle, th_model)
#     return estimate_forces(throttle, est_current)
