#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import division

import numpy as np
import scipy.signal as signal

from vehicle_core.config import thrusters_config as tc


np.set_printoptions(precision=3, suppress=True)

# constants
LPF_FS = 10             # topic sampling frequency (Hz)
LPF_ORDER = 1           # order of the butterworth filter
LPF_CUTOFF = 0.55       # low-pass filter cutoff frequency (Hz) - adjusted with sine_test_20140625 data
LPF_WINDOW = 40         # lpf buffer length (samples)
LATENCY_SAMPLES = 1     # number of samples to delay (modelling of ROS + thruster latency)
THROTTLE_LIMIT = 85     # keep throttle below this limit

# low pass filter (b)
LPF = signal.butter(LPF_ORDER, LPF_CUTOFF / (LPF_FS / 2), 'low', analog=False)

# TODO: remove the tc.XXX dependency to make pythran optimization possible (remove default parameters)
# TODO: remove np.logical statements and use for loops instead (they are faster and make pythran optimization possible)
# TODO: implement manually the IIR filter using the scipy coefficients, this will make pythran optimization possible on all file


def thruster_model_predict(throttle_request, window=LPF_WINDOW, offset=LATENCY_SAMPLES, limit=THROTTLE_LIMIT):
    """This function is calculating the current used by the thrusters from thruster commands

    It returns the predicted throttle for each thruster using a low-pass filter approach.

    :param throttle_request:
    :param window:
    :param offset:
    :param limit:
    :return:
    """

    # apply latency delay
    throttle_delayed = throttle_request[:, 0:(window-offset)]

    # apply low-pass filter
    throttle_model = signal.lfilter(LPF[0], LPF[1], throttle_delayed)

    # calculate the result and apply limits
    throttle_model = np.clip(throttle_model[:,-1], -limit, limit)

    return throttle_model


#pythran export thruster_rate_limiter(float[], float[], int, int)
def thruster_rate_limiter(new_throttle, last_throttle, rising_limit=5, falling_limit=3):
    """Models the change in thruster's throttle.

    http://www.mathworks.co.uk/help/simulink/slref/ratelimiter.html

    :param last_throttle: result of a previous iteration
    :param new_throttle:
    :param rising_limit: rising rate limit between two samples
    :param falling_limit: falling rate limit between two samples
    :return: next_throttle: the new throttle after applying rate limits
    """
    diff_throttle = new_throttle - last_throttle
    next_throttle = np.zeros_like(new_throttle)

    for i, dth in enumerate(diff_throttle):
        if dth > rising_limit:
            next_throttle[i] = last_throttle[i] + rising_limit
        elif dth < -falling_limit:
            next_throttle[i] = last_throttle[i] - falling_limit
        else:
            next_throttle[i] = new_throttle[i]

    return next_throttle


def thruster_model_current(throttle, th_model=(0,1,2,3,4,5)):
    """This function is calculating the current used by the thrusters from thruster commands

    It returns the predicted currents for each thruster using an exponential fitting.

    :param throttle: np.array of shape (6, window)
    :return: i_model: np.array of shape (6,)
    """

    # init and check signs
    est_current = 0
    k_pos = (throttle > 1).astype(int)
    k_neg = (throttle < -1).astype(int)

    # predicted current
    est_current = k_pos * (
        tc.THROTTLE_TO_CURRENT[th_model, 0] * np.exp(tc.THROTTLE_TO_CURRENT[th_model, 1] * throttle) +
        tc.THROTTLE_TO_CURRENT[th_model, 2] * np.exp(tc.THROTTLE_TO_CURRENT[th_model, 3] * throttle)
    ) + k_neg * (
        tc.THROTTLE_TO_CURRENT[th_model, 4] * np.exp(tc.THROTTLE_TO_CURRENT[th_model, 5] * throttle) +
        tc.THROTTLE_TO_CURRENT[th_model, 6] * np.exp(tc.THROTTLE_TO_CURRENT[th_model, 7] * throttle)
    )

    # take into account the effect of small speeds and approximation error (preventing negative values)
    est_current = np.maximum(est_current, 0.0)

    return est_current


def thruster_model_thrust(throttle, current):
    """This function calculates the thrust generated by thrusters from speeds and currents.

    The output is in kilograms as described in thruster's data sheet.

    :param throttle: thrusters input commands (throttle requested, percentage)
    :param current: thruster output currents (measured or predicted by the model, amps)
    :return: estimated thrust generate by thrusters (in kilograms)
    """

    # check signs
    k_pos = (throttle >= 0).astype(int)
    k_neg = (throttle < 0).astype(int)

    # predicted thrust
    thrust_predicted = (
        k_pos * (
            tc.CURRENT_TO_THRUST[0] * (current**3) + tc.CURRENT_TO_THRUST[1] * (current**2) + tc.CURRENT_TO_THRUST[2] * current
        ) + k_neg * -(
            tc.CURRENT_TO_THRUST[3] * (current**3) + tc.CURRENT_TO_THRUST[4] * (current**2) + tc.CURRENT_TO_THRUST[5] * current
        )
    )

    return thrust_predicted


# TODO: this is the main function that shoud be used for the thruster model
def thruster_model_forward(throttle, th_model=(0,1,2,3,4,5)):
    """This functions applies the forward thruster model returning the estimated forces generated by the thrusters.

    :param throttle: thrusters input commands (throttle requested, percentage)
    :return: numpy.ndarray of estimated forces generated by the thrusters according to their models
    """

    est_current = thruster_model_current(throttle, th_model)
    return thruster_model_forces(throttle, est_current)



def thruster_model_forces(throttle, current):
    """This function calculates the thrust generated by thrusters from speeds and currents.

    The output is in newtons as described in thruster's data sheet.

    :param throttle: thrusters input commands (throttle requested, percentage)
    :param current: thruster output currents (measured or predicted by the model, amps)
    :return: estimated thrust generate by thrusters (in newtons)
    """
    return thruster_model_thrust(throttle, current) * 9.81


def thruster_model_throttle(force_request, threshold=0.10, th_model=(0,1,2,3,4,5)):
    """This function calculates the throttle that needs to be sent to the thrusters to apply input
    forces. Inverse of T(i(v)) -> v(T) has been fitted using the thrusters data sheet, thus internally it use kilograms.
    
    :param force_request: np.array of shape (6, 1) of forces in Newtons
    :return: throttle_required: np.array of shape (6, 1) with required throttles
    """

    # calculate required thrust and limit according to vehicle specs
    #   thrust_request: is in kilograms as the fitting is done using thruster's data sheet
    throttle_required = np.zeros_like(force_request[0:6])
    thrust_request = np.clip(force_request[0:6], -tc.MAX_THRUST, tc.MAX_THRUST) / 9.81

    # logic
    k_pos = (thrust_request > threshold)
    k_neg = (thrust_request < -threshold)
    k_lin = np.logical_not(np.logical_or(k_pos, k_neg))     # NOR condition

    k_pos = k_pos.astype(int)
    k_neg = k_neg.astype(int)
    k_lin = k_lin.astype(int)

    throttle_required = (
        # linear approximation around zero
        k_lin * (
            (tc.LINEAR_THROTTLE / threshold) * thrust_request
        ) +

        # exponential approximation
        k_pos * (
            tc.THRUST_TO_THROTTLE[th_model,0] * np.exp(tc.THRUST_TO_THROTTLE[th_model,1] * thrust_request) +
            tc.THRUST_TO_THROTTLE[th_model,2] * np.exp(tc.THRUST_TO_THROTTLE[th_model,3] * thrust_request)
        ) +
        k_neg * (
            tc.THRUST_TO_THROTTLE[th_model,4] * np.exp(tc.THRUST_TO_THROTTLE[th_model,5] * -thrust_request) +
            tc.THRUST_TO_THROTTLE[th_model,6] * np.exp(tc.THRUST_TO_THROTTLE[th_model,7] * -thrust_request)
        )
    )

    return np.clip(throttle_required, -100, 100)
